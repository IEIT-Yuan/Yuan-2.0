{"task_id": "HumanEval/0", "prompt": "问题描述：检查给定数字列表中，是否有任何两个数字之间的距离小于给定的阈值。\n示例：\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n代码如下：\n```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n"}
{"task_id": "HumanEval/1", "prompt": "问题描述：这个函数的输入是一个包含多组嵌套括号的字符串。你的目标是将这些组分离成独立的字符串，并返回这些字符串的列表。独立的组是平衡的（每个开括号都被正确地关闭），并且不在彼此之内嵌套。忽略输入字符串中的任何空格。\n示例：\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']\n代码如下：\n```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n"}
{"task_id": "HumanEval/2", "prompt": "问题描述：给定一个正浮点数，它可以被分解为：整数部分（小于给定数的最大整数）和小数（剩余部分总是小于1）。返回数字的小数部分。\n示例：\n>>> truncate_number(3.5)\n0.5\n代码如下：\n```python\ndef truncate_number(number: float) -> float:\n"}
{"task_id": "HumanEval/3", "prompt": "问题描述：你被给予一个银行账户的存款和取款操作列表，该账户开始时余额为零。你的任务是检测账户余额是否在任何时候下降到零以下，如果是，则函数应返回True。否则，它应返回False。\n示例：\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue\n代码如下：\n```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n"}
{"task_id": "HumanEval/4", "prompt": "问题描述：对于给定的输入数字列表，计算这个数据集平均值周围的平均绝对偏差。平均绝对偏差是每个元素与中心点（本例中为平均值）之间的平均绝对差：MAD = average | x - x_mean |。\n示例：\n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n1.0\n代码如下：\n```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n"}
{"task_id": "HumanEval/5", "prompt": "问题描述：在输入列表 `numbers' 的每两个连续元素之间插入一个数字 'delimeter'。\n示例：\n>>> intersperse([], 4)\n[]\n>>> intersperse([1, 2, 3], 4)\n[1, 4, 2, 4, 3]\n代码如下：\n```python\nfrom typing import List\n\ndef intersperse(numbers, delimeter):\n"}
{"task_id": "HumanEval/6", "prompt": "问题描述：这个函数的输入是一个字符串，表示由空格分隔的多组嵌套括号。对于每一组，输出括号的最深嵌套级别。例如，(()())的最大嵌套级别为两级，而((()))有三级。\n例如：\n>>> parse_nested_parens('(()()) ((())) () ((())()())')\n[2, 3, 1, 3]\n代码如下：\n```python\nfrom typing import List\n\ndef parse_nested_parens(paren_string):\n"}
{"task_id": "HumanEval/7", "prompt": "问题描述：将输入的字符串列表过滤，仅保留包含给定子字符串的项。\n示例：\n>>> filter_by_substring([], 'a')\n[]\n>>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n['abc', 'bacd', 'array']\n代码如下：\n```python\nfrom typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n"}
{"task_id": "HumanEval/8", "prompt": "问题描述：对于给定的整数列表，返回一个元组，该元组由列表中所有整数的和和积组成。空列表的和应等于0，空列表的积应等于1。\n示例：\n>>> sum_product([])\n(0, 1)\n>>> sum_product([1, 2, 3, 4])\n(10, 24)\n代码如下：\n```python\nfrom typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n"}
{"task_id": "HumanEval/9", "prompt": "问题描述：从给定的整数列表中，生成一个序列，该序列在给定时刻显示到目前为止找到的滚动最大元素。\n示例：\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\n代码如下：\n```python\nfrom typing import List, Tuple\n\ndef rolling_max(numbers):\n"}
{"task_id": "HumanEval/10", "prompt": "问题描述：找到以给定的字符串开头的最短回文。算法思想很简单：-找到给定字符串的最长回文后缀。—将回文后缀前的字符串反转，附加到给定字符串的末尾。\n示例：\n>>> make_palindrome('')\n''\n>>> make_palindrome('cat')\n'catac'\n>>> make_palindrome('cata')\n'catac'\n代码如下：\n```python\ndef is_palindrome(string: str) -> bool:\n    \"\"\" 检查给定的字符串是否是回文。 \"\"\"\n    return string == string[::-1]\ndef make_palindrome(string: str) -> str:\n    \"\"\"找到以给定的字符串开头的最短回文。算法思想很简单：-找到给定字符串的最长回文后缀。—将回文后缀前的字符串反转，附加到给定字符串的末尾。\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n"}
{"task_id": "HumanEval/11", "prompt": "问题描述：输入是仅由1和0组成的两个字符串a和b。对这些输入执行二进制异或操作，并以字符串形式返回结果。\n例如，string_xor('010', '110')的结果为'100'。\n代码如下：\n```python\nfrom typing import List\n\ndef string_xor(a: str, b: str) -> str:\n"}
{"task_id": "HumanEval/12", "prompt": "问题描述：从字符串列表中，返回最长的一个。如果有多个字符串长度相同，则返回第一个。如果输入列表为空，则返回None。\n示例：\n>>> longest([])\n\n>>> longest(['a', 'b', 'c'])\n'a'\n>>> longest(['a', 'bb', 'ccc'])\n'ccc'\n代码如下：\n```python\nfrom typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n"}
{"task_id": "HumanEval/13", "prompt": "问题描述：返回两个整数a和b的最大公约数\n示例：\n>>> greatest_common_divisor(3, 5)\n1\n>>> greatest_common_divisor(25, 15)\n5\n代码如下：\n```python\ndef greatest_common_divisor(a: int, b: int) -> int:\n"}
{"task_id": "HumanEval/14", "prompt": "问题描述：返回输入字符串的所有前缀，从最短到最长\n示例：\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\n代码如下：\n```python\nfrom typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n"}
{"task_id": "HumanEval/15", "prompt": "问题描述：返回一个字符串，其中包含从0开始到n（包括n）的空格分隔的数字。\n示例：\n>>> string_sequence(0)\n'0'\n>>> string_sequence(5)\n'0 1 2 3 4 5'\n代码如下：\n```python\ndef string_sequence(n: int) -> str:\n"}
{"task_id": "HumanEval/16", "prompt": "问题描述：给定一个字符串，找出它由多少个不同的字符（不区分大小写）组成\n示例：\n>>> count_distinct_characters('xyzXYZ')\n3\n>>> count_distinct_characters('Jerry')\n4\n代码如下：\n```python\ndef count_distinct_characters(string: str) -> int:\n"}
{"task_id": "HumanEval/17", "prompt": "问题描述：这个函数的输入是一个以特殊ASCII格式表示的音符字符串。你的任务是解析这个字符串，并返回一个整数列表，对应于每个音符持续的拍数。这里是图例：\n'o' - 全音符，持续四拍\n'o|' - 半音符，持续两拍\n'.|' - 四分音符，持续一拍\n示例：\n>>> parse_music('o o| .| o| o| .| .| .| .| o o')\n[4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n代码如下：\n```python\nfrom typing import List\n\ndef parse_music(music_string):\n"}
{"task_id": "HumanEval/18", "prompt": "问题描述：找出给定子字符串在原始字符串中出现的次数。重叠的情况也计算在内。\n示例：\n>>> how_many_times('', 'a')\n0\n>>> how_many_times('aaa', 'a')\n3\n>>> how_many_times('aaaa', 'aa')\n3\n代码如下：\n```python\ndef how_many_times(string: str, substring: str) -> int:\n"}
{"task_id": "HumanEval/19", "prompt": "问题描述：输入是一个由'zero'到'nine'的数字组成的以空格分隔的字符串。有效的选择是'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight'和'nine'。返回从最小到最大排序的数字字符串。\n示例：\n>>> sort_numbers('three one five')\n'one three five'\n代码如下：\n```python\nfrom typing import List\n\ndef sort_numbers(numbers):\n"}
{"task_id": "HumanEval/20", "prompt": "问题描述：从提供的数字列表（长度至少为两个）中选择并返回两个彼此最接近的数字，并按此顺序返回：（较小的数字，较大的数字）。\n示例：\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n(2.0, 2.2)\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n(2.0, 2.0)\n代码如下：\n```python\nfrom typing import List, Tuple\n\ndef find_closest_elements(numbers):\n"}
{"task_id": "HumanEval/21", "prompt": "问题描述：给定一个至少包含两个元素的数字列表，对该列表应用线性变换，使得最小的数字变为0，最大的数字变为1。\n示例：\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]\n代码如下：\n```python\nfrom typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n"}
{"task_id": "HumanEval/22", "prompt": "问题描述：根据给定的Python值列表，仅筛选出整数\n示例：\n>>> filter_integers(['a', 3.14, 5])\n[5]\n>>> filter_integers([1, 2, 3, 'abc', {}, []])\n[1, 2, 3]\n代码如下：\n```python\nfrom typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n"}
{"task_id": "HumanEval/23", "prompt": "问题描述：返回给定字符串的长度\n示例：\n>>> strlen('')\n0\n>>> strlen('abc')\n3\n代码如下：\n```python\ndef strlen(string: str) -> int:\n"}
{"task_id": "HumanEval/24", "prompt": "问题描述：对于给定的数n，找出小于n且能整除n的最大的数。\n示例：\n>>> largest_divisor(15)\n5\n代码如下：\n```python\ndef largest_divisor(n: int) -> int:\n"}
{"task_id": "HumanEval/25", "prompt": "问题描述：返回给定整数的质因数列表，从最小到最大的顺序排列。每个因数应按照其在分解中出现的次数列出。输入的数字应等于所有因数的乘积\n示例：\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n代码如下：\n```python\nfrom typing import List\n\ndef factorize(n: int) -> List[int]:\n"}
{"task_id": "HumanEval/26", "prompt": "问题描述：从整数列表中删除所有出现次数超过一次的元素。保持剩余元素的顺序与输入时相同。\n示例：\n>>> remove_duplicates([1, 2, 3, 2, 4])\n[1, 3, 4]\n代码如下：\n```python\nfrom typing import List\n\ndef remove_duplicates(numbers):\n"}
{"task_id": "HumanEval/27", "prompt": "问题描述：对于给定的字符串，将小写字符转换为大写，将大写字符转换为小写。\n示例：\n>>> flip_case('Hello')\n'hELLO'\n代码如下：\n```python\ndef flip_case(string: str) -> str:\n"}
{"task_id": "HumanEval/28", "prompt": "问题描述：将字符串列表连接成一个单独的字符串\n示例：\n>>> concatenate([])\n''\n>>> concatenate(['a', 'b', 'c'])\n'abc'\n代码如下：\n```python\nfrom typing import List\n\ndef concatenate(strings: List[str]) -> str:\n"}
{"task_id": "HumanEval/29", "prompt": "问题描述：过滤一个字符串列表，只保留以给定前缀开头的字符串。\n示例：\n>>> filter_by_prefix([], 'a')\n[]\n>>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n['abc', 'array']\n代码如下：\n```python\nfrom typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n"}
{"task_id": "HumanEval/30", "prompt": "问题描述：只返回列表中的正数。\n示例：\n>>> get_positive([-1, 2, -4, 5, 6])\n[2, 5, 6]\n>>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n[5, 3, 2, 3, 9, 123, 1]\n代码如下：\n```python\ndef get_positive(l: list):\n"}
{"task_id": "HumanEval/31", "prompt": "问题描述：如果给定的数字是质数，则返回真，否则返回假。\n示例：\n>>> is_prime(6)\nFalse\n>>> is_prime(101)\nTrue\n>>> is_prime(11)\nTrue\n>>> is_prime(13441)\nTrue\n>>> is_prime(61)\nTrue\n>>> is_prime(4)\nFalse\n>>> is_prime(1)\nFalse\n代码如下：\n```python\ndef is_prime(n):\n"}
{"task_id": "HumanEval/32", "prompt": "问题描述：xs是多项式的系数。查找满足poly(x) = 0的x值。函数find_zero只返回一个零点，即使有多个零点。此外，函数find_zero只接受具有偶数个系数和最大非零系数的列表xs，因为这样可以保证有一个解。\n示例：\n>>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n-0.5\n>>> round(find_zero([-6, 11, -6, 1]), 2) # f(x) = (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n1.0\n代码如下：\n```python\nimport math\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    求解点x处系数为xs的多项式。\n    返回xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n。\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\ndef find_zero(xs: list):\n    \"\"\"\n    xs是多项式的系数。find_zero返回poly(x)= 0时的解。函数find_zero只返回一个零点，即使有多个零点。此外，函数find_zero只接受具有偶数个系数和最大非零系数的列表xs，因为这样可以保证有一个解。\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n"}
{"task_id": "HumanEval/33", "prompt": "问题描述：这个函数接收一个列表l，返回一个列表l'，满足以下条件：l'与l在不能被3整除的索引处完全相同，而在能被3整除的索引处的值等于l中对应索引的值，但是排好序。\n示例：\n>>> sort_third([1, 2, 3])\n[1, 2, 3]\n>>> sort_third([5, 6, 3, 4, 8, 9, 2])\n[2, 6, 3, 4, 8, 9, 5]\n代码如下：\n```python\ndef sort_third(l):\n"}
{"task_id": "HumanEval/34", "prompt": "问题描述：返回列表中排序后的唯一元素。\n示例：\n>>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[0, 2, 3, 5, 9, 123]\n代码如下：\n```python\ndef unique(l):\n"}
{"task_id": "HumanEval/35", "prompt": "问题描述：返回列表中的最大元素。\n示例：\n>>> max_element([1, 2, 3])\n3\n>>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n123\n代码如下：\n```python\ndef max_element(l: list):\n"}
{"task_id": "HumanEval/36", "prompt": "问题描述：返回小于n的整数中，能够被11或13整除的数字中，数字7出现的次数。\n示例：\n>>> fizz_buzz(50)\n0\n>>> fizz_buzz(78)\n2\n>>> fizz_buzz(79)\n3\n代码如下：\n```python\ndef fizz_buzz(n):\n"}
{"task_id": "HumanEval/37", "prompt": "问题描述：这个函数接受一个列表l，并返回一个新的列表l'，使得l'与l在奇数索引处完全相同，而它在偶数索引处的值等于l的偶数索引处的值，但是已经排序。\n示例：\n>>> sort_even([1, 2, 3])\n[1, 2, 3]\n>>> sort_even([5, 6, 3, 4])\n[3, 6, 5, 4]\n代码如下：\n```python\ndef sort_even(l):\n"}
{"task_id": "HumanEval/38", "prompt": "问题描述：输入encode_cyclic函数编码的字符串，返回解码后的字符串。\n代码如下：\n```python\ndef encode_cyclic(s: str):\n    \"\"\"\n    返回通过循环移动3个字符编码的字符串。\n    \"\"\"\n    # 将字符串拆分为组，每个组的长度为3。\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # 在每个组中循环元素，除非该组的元素少于3个。\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\ndef decode_cyclic(s: str):\n    \"\"\"\n    输入encode_cyclic函数编码的字符串，返回解码后的字符串。\n    \"\"\"\n"}
{"task_id": "HumanEval/39", "prompt": "问题描述：prime_fib返回第n个既是斐波那契数又是质数的数字。\n示例：\n>>> prime_fib(1)\n2\n>>> prime_fib(2)\n3\n>>> prime_fib(3)\n5\n>>> prime_fib(4)\n13\n>>> prime_fib(5)\n89\n代码如下：\n```python\ndef prime_fib(n):\n"}
{"task_id": "HumanEval/40", "prompt": "问题描述：\"triples_sum_to_zero\"接收一个整数列表作为输入。如果列表中有三个不同的元素相加等于零，它将返回True，否则返回False。\n示例：\n>>> triples_sum_to_zero([1, 3, 5, 0])\nFalse\n>>> triples_sum_to_zero([1, 3, -2, 1])\nTrue\n>>> triples_sum_to_zero([1, 2, 3, 7])\nFalse\n>>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\nTrue\n>>> triples_sum_to_zero([1])\nFalse\n代码如下：\n```python\ndef triples_sum_to_zero(l: list):\n"}
{"task_id": "HumanEval/41", "prompt": "问题描述：想象一条完美的直线无限长的道路。n辆车从左向右行驶；同时，另外n辆车从右向左行驶。这两组车开始时彼此相距非常远。所有的车都以相同的速度移动。当一辆从左向右行驶的车撞到一辆从右向左行驶的车时，我们称之为碰撞。然而，这些车都无比坚固强大；因此，即使它们发生了碰撞，也会继续按照原来的轨迹行驶。这个函数输出这样的碰撞次数。\n代码如下：\n```python\ndef car_race_collision(n):\n"}
{"task_id": "HumanEval/42", "prompt": "问题描述：返回一个元素增加1的列表。\n示例：\n>>> incr_list([1, 2, 3])\n[2, 3, 4]\n>>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[6, 4, 6, 3, 4, 4, 10, 1, 124]\n代码如下：\n```python\ndef incr_list(l: list):\n"}
{"task_id": "HumanEval/43", "prompt": "问题描述：\"pairs_sum_to_zero\"接收一个整数列表作为输入。如果列表中有两个不同的元素之和等于零，则返回True，否则返回False。\n例如：\n>>> pairs_sum_to_zero([1, 3, 5, 0])\n返回 False\n>>> pairs_sum_to_zero([1, 3, -2, 1])\n返回 False\n>>> pairs_sum_to_zero([1, 2, 3, 7])\n返回 False\n>>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n返回 True\n>>> pairs_sum_to_zero([1])\n返回 False\n代码如下：\n```python\ndef pairs_sum_to_zero(l):\n"}
{"task_id": "HumanEval/44", "prompt": "问题描述：将输入数字x转换为基数。转换后返回字符串表示。基数小于10。\n示例：\n>>> change_base(8, 3)\n'22'\n>>> change_base(8, 2)\n'1000'\n>>> change_base(7, 2)\n'111'\n代码如下：\n```python\ndef change_base(x: int, base: int):\n"}
{"task_id": "HumanEval/45", "prompt": "问题描述：给定三角形的一边长和高，返回其面积。\n示例：\n>>> triangle_area(5, 3)\n7.5\n代码如下：\n```python\ndef triangle_area(a, h):\n"}
{"task_id": "HumanEval/46", "prompt": "问题描述：Fib4 数列是一个类似于斐波那契数列的序列，其定义如下：\nfib4(0) -> 0\nfib4(1) -> 0\nfib4(2) -> 2\nfib4(3) -> 0\nfib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n请编写一个函数，用于高效计算 fib4 数列的第 n 个元素。请不要使用递归。\n示例：\n>>> fib4(5)\n4\n>>> fib4(6)\n8\n>>> fib4(7)\n14\n代码如下：\n```python\ndef fib4(n):\n"}
{"task_id": "HumanEval/47", "prompt": "问题描述：返回列表l中元素的中位数。\n示例：\n>>> median([3, 1, 2, 4, 5])\n3\n>>> median([-10, 4, 6, 1000, 10, 20])\n15.0\n代码如下：\n```python\ndef median(l: list):\n"}
{"task_id": "HumanEval/48", "prompt": "问题描述：检查给定的字符串是否为回文\n示例：\n>>> is_palindrome('')\nTrue\n>>> is_palindrome('aba')\nTrue\n>>> is_palindrome('aaaaa')\nTrue\n>>> is_palindrome('zbcd')\nFalse\n代码如下：\n```python\ndef is_palindrome(text: str):\n"}
{"task_id": "HumanEval/49", "prompt": "问题描述：返回 2^n modulo p 的值（注意数值处理）。\n示例：\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n代码如下：\n```python\ndef modp(n, p):\n"}
{"task_id": "HumanEval/50", "prompt": "问题描述：输入encode_shift函数编码的字符串。返回解码的字符串。\n代码如下：\n```python\ndef encode_shift(s: str):\n    \"\"\"\n    返回通过在字母表中将每个字符移动5位得到的编码字符串。\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\ndef decode_shift(s: str):\n    \"\"\" \n    输入encode_shift函数编码的字符串。返回解码的字符串。\n    \"\"\"\n"}
{"task_id": "HumanEval/51", "prompt": "问题描述：remove_vowels是一个函数，它接受一个字符串并返回一个没有元音字母的字符串。\n示例：\n>>> remove_vowels('')\n''\n>>> remove_vowels(\"abcdef\\nghijklm\")\n'bcdf\\nghjklm'\n>>> remove_vowels('abcdef')\n'bcdf'\n>>> remove_vowels('aaaaa')\n''\n>>> remove_vowels('aaBAA')\n'B'\n>>> remove_vowels('zbcd')\n'zbcd'\n代码如下：\n```python\ndef remove_vowels(text):\n"}
{"task_id": "HumanEval/52", "prompt": "问题描述：如果列表l中的所有数字都低于阈值t，则返回True。\n示例：\n>>> below_threshold([1, 2, 4, 10], 100)\nTrue\n>>> below_threshold([1, 20, 4, 10], 5)\nFalse\n代码如下：\n```python\ndef below_threshold(l: list, t: int):\n"}
{"task_id": "HumanEval/53", "prompt": "问题描述：将两个数字x和y相加\n示例：\n>>> add(2, 3)\n5\n>>> add(5, 7)\n12\n代码如下：\n```python\ndef add(x: int, y: int):\n"}
{"task_id": "HumanEval/54", "prompt": "问题描述：检查两个单词是否具有相同的字符。\n示例：\n>>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\nTrue\n>>> same_chars('abcd', 'dddddddabc')\nTrue\n>>> same_chars('dddddddabc', 'abcd')\nTrue\n>>> same_chars('eabcd', 'dddddddabc')\nFalse\n>>> same_chars('abcd', 'dddddddabce')\nFalse\n>>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\nFalse\n代码如下：\n```python\ndef same_chars(s0, s1):\n"}
{"task_id": "HumanEval/55", "prompt": "问题描述：返回第n个斐波那契数。\n示例：\n>>> fib(10)\n55\n>>> fib(1)\n1\n>>> fib(8)\n21\n代码如下：\n```python\ndef fib(n: int):\n"}
{"task_id": "HumanEval/56", "prompt": "问题描述：\"brackets\"是一个由\"<\"和\">\"组成的字符串。如果每个开括号都有对应的闭括号，则返回True。\n示例：\n>>> correct_bracketing(\"<\")\nFalse\n>>> correct_bracketing(\"<>\")\nTrue\n>>> correct_bracketing(\"<<><>>\")\nTrue\n>>> correct_bracketing(\"><<>\")\nFalse\n代码如下：\n```python\ndef correct_bracketing(brackets: str):\n"}
{"task_id": "HumanEval/57", "prompt": "问题描述：如果列表元素是单调递增或递减的，则返回True。\n示例：\n>>> monotonic([1, 2, 4, 20])\nTrue\n>>> monotonic([1, 20, 4, 10])\nFalse\n>>> monotonic([4, 1, 0, -10])\nTrue\n代码如下：\n```python\ndef monotonic(l):\n"}
{"task_id": "HumanEval/58", "prompt": "问题描述：返回两个列表中排序后的唯一公共元素。\n示例：\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n[1, 5, 653]\n>>> common([5, 3, 2, 8], [3, 2])\n[2, 3]\n代码如下：\n```python\ndef common(l1: list, l2: list):\n"}
{"task_id": "HumanEval/59", "prompt": "问题描述：返回n的最大质数因子。假设n>1且不是质数。\n示例：\n>>> largest_prime_factor(13195)\n29\n>>> largest_prime_factor(2048)\n2\n代码如下：\n```python\ndef largest_prime_factor(n):\n"}
{"task_id": "HumanEval/60", "prompt": "问题描述：sum_to_n是一个函数，用于求和从1到n的数字。\n示例：\n>>> sum_to_n(30)\n465\n>>> sum_to_n(100)\n5050\n>>> sum_to_n(5)\n15\n>>> sum_to_n(10)\n55\n>>> sum_to_n(1)\n1\n代码如下：\n```python\ndef sum_to_n(n: int):\n"}
{"task_id": "HumanEval/61", "prompt": "问题描述：\"brackets\"是一个由\"(\"和\")\"组成的字符串。如果每个开括号都有对应的闭括号，则返回True。\n示例：\n>>> correct_bracketing(\"(\")\nFalse\n>>> correct_bracketing(\"()\")\nTrue\n>>> correct_bracketing(\"(()())\")\nTrue\n>>> correct_bracketing(\")(()\")\nFalse\n代码如下：\n```python\ndef correct_bracketing(brackets: str):\n"}
{"task_id": "HumanEval/62", "prompt": "问题描述：xs代表多项式的系数。xs[0] + xs[1] * x + xs[2] * x^2 + ....以同样的形式返回这个多项式的导数。\n示例：\n>>> derivative([3, 1, 2, 4, 5])\n[1, 4, 12, 20]\n>>> derivative([1, 2, 3])\n[2, 6]\n代码如下：\n```python\ndef derivative(xs):\n"}
{"task_id": "HumanEval/63", "prompt": "问题描述：FibFib数列是一个类似于斐波那契数列的序列，其定义如下：\nfibfib(0) == 0\nfibfib(1) == 0\nfibfib(2) == 1\nfibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n请编写一个函数，有效地计算出FibFib数列的第n个元素。\n示例：\n>>> fibfib(1)\n0\n>>> fibfib(5)\n4\n>>> fibfib(8)\n24\n代码如下：\n```python\ndef fibfib(n):\n"}
{"task_id": "HumanEval/64", "prompt": "问题描述：编写一个函数vowels_count，它接受一个表示单词的字符串作为输入，并返回该字符串中元音字母的数量。这里的元音字母是'a'、'e'、'i'、'o'、'u'。此外，当'y'位于单词的末尾时，也视为元音字母。\n示例：\n>>> vowels_count(\"abcde\")\n2\n>>> vowels_count(\"ACEDY\")\n3\n代码如下：\n```python\ndef vowels_count(s):\n"}
{"task_id": "HumanEval/65", "prompt": "问题描述：将整数x的数字进行循环移位，向右移动shift位，并将结果以字符串形式返回。如果shift > 数字的位数，则返回倒序的数字。\n例如：\n>>> circular_shift(12, 1)\n\"21\"\n>>> circular_shift(12, 2)\n\"12\"\n代码如下：\n```python\ndef circular_shift(x, shift):\n"}
{"task_id": "HumanEval/66", "prompt": "问题描述：编写一个函数，该函数接收一个字符串作为输入，并返回仅包含大写字符的ASCII码之和。\n示例：\n    digitSum(\"\") => 0\n    digitSum(\"abAB\") => 131\n    digitSum(\"abcCd\") => 67\n    digitSum(\"helloE\") => 69\n    digitSum(\"woArBld\") => 131\n    digitSum(\"aAaaaXa\") => 153\n代码如下：\n```python\ndef digitSum(s):\n"}
{"task_id": "HumanEval/67", "prompt": "问题描述：在这个任务中，你将得到一个字符串，表示分布在水果篮子中的苹果和橙子的数量。这个篮子里装有苹果、橙子和芒果。给定代表橙子和苹果总数的字符串以及代表篮子中水果总数的整数，返回篮子中芒果的数量。\n例如：\nfruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\nfruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\nfruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\nfruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n代码如下：\n```python\ndef fruit_distribution(s,n):\n"}
{"task_id": "HumanEval/68", "prompt": "问题描述：\"给定一个表示树枝的数组，该树枝由非负整数节点组成，你的任务是摘下其中一个节点并返回。应摘下具有最小偶数值的节点。如果发现多个具有相同最小偶数值的节点，则返回索引最小的节点。应以列表的形式返回摘下的节点，[ 最小值, 其索引 ]，如果没有偶数值或给定数组为空，则返回 []。\n示例 1:\n    输入: [4,2,3]\n    输出: [2, 1]\n    解释: 2 是最小的偶数值，且 2 的索引最小。\n示例 2:\n    输入: [1,2,3]\n    输出: [2, 1]\n    解释: 2 是最小的偶数值，且 2 的索引最小。 \n示例 3:\n    输入: []\n    输出: []\n示例 4:\n    输入: [5, 0, 3, 0, 4, 2]\n    输出: [0, 1]\n    解释: 0 是最小的值，但有两个零，所以我们选择第一个零，它的索引最小。\n约束条件:\n    * 节点的长度在 1 到 10000 之间\n    * 节点的值大于等于 0\"\n代码如下：\n```python\ndef pluck(arr):\n"}
{"task_id": "HumanEval/69", "prompt": "问题描述：你得到了一个非空的正整数列表。返回大于零的最大整数，其频率大于或等于该整数本身的值。整数的频率是它在列表中出现的次数。如果不存在这样的值，返回-1。\n示例：\nsearch([4, 1, 2, 2, 3, 1]) == 2\nsearch([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\nsearch([5, 5, 4, 4, 4]) == -1\n代码如下：\n```python\ndef search(lst):\n"}
{"task_id": "HumanEval/70", "prompt": "问题描述：给定一个整数列表，按照奇特的顺序返回列表。这种奇特的排序方式是，你先从最小值开始，然后是剩余整数中的最大值，然后是最小值，依此类推。\n示例：\nstrange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\nstrange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\nstrange_sort_list([]) == []\n代码如下：\n```python\ndef strange_sort_list(lst):\n"}
{"task_id": "HumanEval/71", "prompt": "问题描述：给定三角形的三条边的长度。如果这三条边可以构成一个有效的三角形，则返回该三角形的面积，结果保留两位小数。否则返回-1。三个边能构成有效的三角形的条件是任何两边之和大于第三边。\n示例：\ntriangle_area(3, 4, 5) == 6.00\ntriangle_area(1, 2, 10) == -1\n代码如下：\n```python\ndef triangle_area(a, b, c):\n"}
{"task_id": "HumanEval/72", "prompt": "问题描述：编写一个函数，如果对象q能飞则返回True，否则返回False。对象q能飞的条件是它平衡（它是一个回文列表）并且其元素之和小于或等于最大可能重量w。\n示例：\nwill_it_fly([1, 2], 5) ➞ False \n# 1+2小于最大可能的重量，但它不平衡。\nwill_it_fly([3, 2, 3], 1) ➞ False\n# 它是平衡的，但3+2+3大于最大可能的重量。\nwill_it_fly([3, 2, 3], 9) ➞ True\n# 3+2+3小于最大可能的重量，并且它是平衡的。\nwill_it_fly([3], 5) ➞ True\n# 3小于最大可能的重量，并且它是平衡的。\n代码如下：\n```python\ndef will_it_fly(q,w):\n"}
{"task_id": "HumanEval/73", "prompt": "问题描述：给定一个整数数组arr，找出需要改变的最少元素数量以使数组成为回文数组。回文数组是指正向和反向读取都相同的数组。在一次更改中，你可以将一个元素更改为任何其他元素。\n例如：\nsmallest_change([1,2,3,5,4,7,9,6]) == 4\nsmallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\nsmallest_change([1, 2, 3, 2, 1]) == 0\n代码如下：\n```python\ndef smallest_change(arr):\n"}
{"task_id": "HumanEval/74", "prompt": "问题描述：编写一个函数，该函数接受两个字符串列表，并返回总字符数少于另一个列表的所有字符串的列表。如果这两个列表的字符数相同，那么返回第一个列表。\n示例：\ntotal_match([], []) ➞ []\ntotal_match(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\ntotal_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\ntotal_match(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\ntotal_match(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n代码如下：\n```python\ndef total_match(lst1, lst2):\n"}
{"task_id": "HumanEval/75", "prompt": "问题描述：编写一个函数，如果给定的数字是3个质数的乘积，则返回True，否则返回False。已知（a）小于100。\n例如：\nis_multiply_prime(30) == True\n30 = 2 * 3 * 5\n代码如下：\n```python\ndef is_multiply_prime(a):\n"}
{"task_id": "HumanEval/76", "prompt": "问题描述：你需要编写一个函数，如果数字x是n的简单幂则返回true，否则返回false。x是n的简单幂是指n的某个整数次幂等于x。\n例如：\nis_simple_power(1, 4) => true\nis_simple_power(2, 2) => true\nis_simple_power(8, 2) => true\nis_simple_power(3, 2) => false\nis_simple_power(3, 1) => false\nis_simple_power(5, 3) => false\n代码如下：\n```python\ndef is_simple_power(x, n):\n"}
{"task_id": "HumanEval/77", "prompt": "问题描述：编写一个函数，该函数接收一个整数a，如果这个整数是某个整数的立方，则返回True。注意：你可以假设输入总是有效的。\n示例：\niscube(1) ==> True\niscube(2) ==> False\niscube(-1) ==> True\niscube(64) ==> True\niscube(0) ==> True\niscube(180) ==> False\n代码如下：\n```python\ndef iscube(a):\n"}
{"task_id": "HumanEval/78", "prompt": "问题描述：你需要编写一个函数，这个函数接收一个字符串形式的十六进制数，并计算其中是质数的十六进制数字的数量（质数是大于1的自然数，不能由两个较小的自然数的乘积得到）。十六进制的数字包括0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F。质数包括2, 3, 5, 7, 11, 13, 17等等。所以你需要确定以下数字的数量：2, 3, 5, 7, B（等于十进制的11）, D（等于十进制的13）。注意：你可以假设输入总是正确的或者是空字符串，并且符号A,B,C,D,E,F总是大写的。\n例如：\n对于 num = \"AB\"，输出应该是1。\n对于 num = \"1077E\"，输出应该是2。\n对于 num = \"ABED1A33\"，输出应该是4。\n对于 num = \"123456789ABCDEF0\"，输出应该是6。\n对于 num = \"2020\"，输出应该是2。\n代码如下：\n```python\ndef hex_key(num):\n"}
{"task_id": "HumanEval/79", "prompt": "问题描述：你将会得到一个十进制形式的数字，你的任务是将它转换为二进制格式。该函数应返回一个字符串，每个字符代表一个二进制数。字符串中的每个字符将是'0'或'1'。字符串的开始和结束处将有额外的一对字符'db'。这些额外的字符是用来帮助格式化的。\n示例：\ndecimal_to_binary(15)   # 返回 \"db1111db\"\ndecimal_to_binary(32)   # 返回 \"db100000db\"\n代码如下：\n```python\ndef decimal_to_binary(decimal):\n"}
{"task_id": "HumanEval/80", "prompt": "问题描述：你被赋予一个字符串s。你的任务是检查这个字符串是否是\"快乐的\"。如果一个字符串的长度至少为3且每3个连续的字母都是不同的，那么这个字符串就是\"快乐的\"。\n例如：\nis_happy(a) => False\nis_happy(aa) => False\nis_happy(abcd) => True\nis_happy(aabb) => False\nis_happy(adb) => True\nis_happy(xyy) => False\n代码如下：\n```python\ndef is_happy(s):\n"}
{"task_id": "HumanEval/81", "prompt": "问题描述：这是学期的最后一周，老师需要给学生打分。老师一直在自己制定评分的算法。唯一的问题是，她丢失了用于评分的代码。她给了你一些学生的GPA列表，你需要编写一个函数，可以根据以下表格输出一个字母等级的列表：\n         GPA       |    字母等级\n          4.0                A+\n        > 3.7                A \n        > 3.3                A- \n        > 3.0                B+\n        > 2.7                B \n        > 2.3                B-\n        > 2.0                C+\n        > 1.7                C\n        > 1.3                C-\n        > 1.0                D+ \n        > 0.7                D \n        > 0.0                D-\n          0.0                E\n\n示例：\ngrade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n代码如下：\n```python\ndef numerical_letter_grade(grades):\n"}
{"task_id": "HumanEval/82", "prompt": "问题描述：编写一个函数，该函数接收一个字符串，并返回该字符串的长度是否为素数。如果是素数则返回True，否则返回False。\n示例：\nprime_length('Hello') == True\nprime_length('abcdcba') == True\nprime_length('kittens') == True\nprime_length('orange') == False\n代码如下：\n```python\ndef prime_length(string):\n"}
{"task_id": "HumanEval/83", "prompt": "问题描述：给定一个正整数n，返回以1开始或结束的n位正整数的数量。\n代码如下：\n```python\ndef starts_one_ends(n):\n"}
{"task_id": "HumanEval/84", "prompt": "问题描述：给定一个正整数N，以二进制形式返回N的各位数字的总和。\n示例：\n对于 N = 1000，数位之和为1，输出应为\"1\"。\n对于 N = 150，数位之和为6，输出应为\"110\"。\n对于 N = 147，数位之和为12，输出应为\"1100\"。\n变量:\n@N 整数\n     约束条件: 0 ≤ N ≤ 10000。\n输出:\n 一个二进制数的字符串\n代码如下：\n```python\ndef solve(N):\n"}
{"task_id": "HumanEval/85", "prompt": "问题描述：给定一个非空的整数列表 lst。加总位于奇数索引的偶数元素。\n示例：\n    add([4, 2, 6, 7]) ==> 2\n代码如下：\n```python\ndef add(lst):\n"}
{"task_id": "HumanEval/86", "prompt": "问题描述：编写一个函数，该函数接收一个字符串并返回其有序版本。字符串的有序版本是指一个新的字符串，其中所有的单词（由空格分隔）都被替换成了新的单词，新单词中所有的字符都按照ASCII值的升序排列。注意：你应该保持句子中单词和空格的顺序。\n例如：\nanti_shuffle('Hi') 返回 'Hi'\nanti_shuffle('hello') 返回 'ehllo'\nanti_shuffle('Hello World!!!') 返回 'Hello !!!Wdlor'\n代码如下：\n```python\ndef anti_shuffle(s):\n"}
{"task_id": "HumanEval/87", "prompt": "问题描述：你将获得一个二维数据，作为嵌套列表，这类似于矩阵，但与矩阵不同的是，每一行可能包含不同数量的列。给定列表 lst 和整数 x，找到列表中的整数 x，并返回元组列表 [(x1, y1), (x2, y2) ...]，每个元组都是一个坐标 - (行, 列)，从0开始。首先按行以升序排序坐标。同时，按列以降序排序行的坐标。\n示例：\nget_row([\n  [1,2,3,4,5,6],\n  [1,2,3,4,1,6],\n  [1,2,3,4,5,1]\n], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\nget_row([], 1) == []\nget_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n代码如下：\n```python\ndef get_row(lst, x):\n"}
{"task_id": "HumanEval/88", "prompt": "问题描述：给定一个非负整数数组，返回排序后的数组副本，如果数组的第一个值和最后一个值的和是奇数，则按升序排序数组，如果这个和是偶数，则按降序排序数组。\n注意：\n* 不要改变给定的数组。\n示例：\n* sort_array([]) => []\n* sort_array([5]) => [5]\n* sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n* sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n代码如下：\n```python\ndef sort_array(array):\n"}
{"task_id": "HumanEval/89", "prompt": "问题描述：创建一个函数encrypt，该函数读入一个字符串作为参数，返回一个通过字母表旋转加密得到的字符串。字母表应该以这样的方式旋转，即每个字母在字母表中向后移动2乘以2个位置。\n例如：\nencrypt('hi') 返回 'lm'\nencrypt('asdfghjkl') 返回 'ewhjklnop'\nencrypt('gf') 返回 'kj'\nencrypt('et') 返回 'ix'\n代码如下：\n```python\ndef encrypt(s):\n"}
{"task_id": "HumanEval/90", "prompt": "问题描述：你将得到一个整数列表。编写一个函数 next_smallest()，该函数返回列表中第二小的元素。如果没有这样的元素，则返回 None。\n示例：\nnext_smallest([1, 2, 3, 4, 5]) == 2\nnext_smallest([5, 1, 4, 3, 2]) == 2\nnext_smallest([]) == None\nnext_smallest([1, 1]) == None\n代码如下：\n```python\ndef next_smallest(lst):\n"}
{"task_id": "HumanEval/91", "prompt": "问题描述：给定一个由单词组成的字符串，你的任务是计算其中boredom的数量。 boredom指的是以\"I\"开头的句子。\n句子由 '.', '?' 或者 '!'分隔。\n例如：\n>>> is_bored(\"Hello world\")\n0\n>>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n1\n代码如下：\n```python\ndef is_bored(S):\n"}
{"task_id": "HumanEval/92", "prompt": "问题描述：创建一个接收三个数字的函数。如果其中一个数字等于另外两个数字的和，并且所有数字都是整数，则返回True。在任何其他情况下，返回False。\n示例：\nany_int(5, 2, 7) ➞ True\nany_int(3, 2, 2) ➞ False\nany_int(3, -2, 1) ➞ True\nany_int(3.6, -2.2, 2) ➞ False\n代码如下：\n```python\ndef any_int(x, y, z):\n"}
{"task_id": "HumanEval/93", "prompt": "问题描述：编写一个函数，该函数接收一条消息，并以一种方式进行编码，即交换所有字母的大小写，并将消息中的所有元音替换为英文字母表中该元音后两位的字母。假设只有字母。\n示例：\n>>> encode('test')\n'TGST'\n>>> encode('This is a message')\n'tHKS KS C MGSSCGG'\n代码如下：\n```python\ndef encode(message):\n"}
{"task_id": "HumanEval/94", "prompt": "问题描述：你将获得一个整数列表。你需要找出其中最大的质数，并返回这个最大质数的各位数字之和。\n示例：\n对于 lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]，输出应为 10\n对于 lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]，输出应为 25\n对于 lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]，输出应为 13\n对于 lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6]，输出应为 11\n对于 lst = [0,81,12,3,1,21]，输出应为 3\n对于 lst = [0,8,1,2,1,7]，输出应为 7\n代码如下：\n```python\ndef skjkasdkd(lst):\n"}
{"task_id": "HumanEval/95", "prompt": "问题描述：给定一个字典，如果所有键都是小写字符串或所有键都是大写字符串，则返回True，否则返回False。如果给定的字典为空，则返回False。\n示例：\ncheck_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) 应返回True。\ncheck_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) 应返回False。\ncheck_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) 应返回False。\ncheck_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) 应返回False。\ncheck_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) 应返回True。\n代码如下：\n```python\ndef check_dict_case(dict):\n"}
{"task_id": "HumanEval/96", "prompt": "问题描述：实现一个函数，该函数接收一个非负整数，并返回一个数组，数组中是小于n的前n个素数。\n例如：\ncount_up_to(5) => [2,3]\ncount_up_to(11) => [2,3,5,7]\ncount_up_to(0) => []\ncount_up_to(20) => [2,3,5,7,11,13,17,19]\ncount_up_to(1) => []\ncount_up_to(18) => [2,3,5,7,11,13,17]\n代码如下：\n```python\ndef count_up_to(n):\n"}
{"task_id": "HumanEval/97", "prompt": "问题描述：完成一个函数，读入两个整数，并返回它们个位数乘积。假设输入始终有效。\n示例：\nmultiply(148, 412) 应返回 16。\nmultiply(19, 28) 应返回 72。\nmultiply(2020, 1851) 应返回 0。\nmultiply(14,-15) 应返回 20。\n代码如下：\n```python\ndef multiply(a, b):\n"}
{"task_id": "HumanEval/98", "prompt": "问题描述：给定一个字符串s，计算偶数索引上的大写元音字母的数量。\n例如：\ncount_upper('aBCdEf') 返回 1\ncount_upper('abcdefg') 返回 0\ncount_upper('dBBE') 返回 0\n代码如下：\n```python\ndef count_upper(s):\n"}
{"task_id": "HumanEval/99", "prompt": "问题描述：创建一个函数，该函数接收一个代表数字的字符串值，并返回最接近它的整数。如果该数字与两个整数等距离，那么向零的反方向取整。\n示例：\n>>> closest_integer(\"10\")\n10\n>>> closest_integer(\"15.3\")\n15\n注意：\n向零的反方向取整意味着，如果给定的数字与两个整数等距离，你应返回的是离零最远的那个。例如，closest_integer(\"14.5\") 应返回 15，closest_integer(\"-14.5\") 应返回 -15。\n代码如下：\n```python\ndef closest_integer(value):\n"}
{"task_id": "HumanEval/100", "prompt": "问题描述：给定一个正整数n，你需要堆积n层的石头。\n第一层有n块石头。\n下一层石头的数量是：\n    - 如果n是奇数，则为下一个奇数。\n    - 如果n是偶数，则为下一个偶数。\n返回一个列表，其中每个元素代表每一层的石头数量，索引i代表第（i+1）层。\n示例：\n>>> make_a_pile(3)\n[3, 5, 7]\n代码如下：\n```python\ndef make_a_pile(n):\n"}
{"task_id": "HumanEval/101", "prompt": "问题描述：你将获得一个由逗号或空格分隔的字符串。你的任务是将字符串分割成单词，并返回一个包含这些单词的数组。\n例如：\nwords_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\nwords_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n代码如下：\n```python\ndef words_string(s):\n"}
{"task_id": "HumanEval/102", "prompt": "问题描述：这个函数接受两个正数x和y，并返回在[x, y]范围内（包括x和y）的最大偶数。如果该范围内没有符合条件的数字，那么函数应返回-1。\n例如：\nchoose_num(12, 15) = 14\nchoose_num(13, 12) = -1\n代码如下：\n```python\ndef choose_num(x, y):\n"}
{"task_id": "HumanEval/103", "prompt": "问题描述：你将得到两个正整数n和m，你的任务是计算从n到m（包括n和m）的整数的平均值。将答案四舍五入到最接近的整数，并将其转换为二进制。如果n大于m，返回-1。\n示例：\nrounded_avg(1, 5) => \"0b11\"\nrounded_avg(7, 5) => -1\nrounded_avg(10, 20) => \"0b1111\"\nrounded_avg(20, 33) => \"0b11010\"\n代码如下：\n```python\ndef rounded_avg(n, m):\n"}
{"task_id": "HumanEval/104", "prompt": "问题描述：给定一个正整数列表x。返回一个已排序的列表，该列表包含所有没有任何偶数位的元素。\n注意：返回的列表应按递增顺序排序。\n例如：\n>>> unique_digits([15, 33, 1422, 1])\n[1, 15, 33]\n>>> unique_digits([152, 323, 1422, 10])\n[]\n代码如下：\n```python\ndef unique_digits(x):\n"}
{"task_id": "HumanEval/105", "prompt": "问题描述：给定一个整数数组，将其中1至9（包括1和9）的整数进行排序，然后反转结果数组，最后将每个数字替换为对应的名称，即\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"。\n例如：\n  arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n    -> 排序 arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n    -> 反转 arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n  返回 [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n如果数组为空，则返回一个空数组：\n  arr = []\n  返回 []\n如果数组中有任何异常数字，忽略它：\n  arr = [1, -1 , 55] \n    -> 排序 arr -> [-1, 1, 55]\n    -> 反转 arr -> [55, 1, -1]\n  返回 ['One']\n代码如下：\n```python\ndef by_length(arr):\n"}
{"task_id": "HumanEval/106", "prompt": "问题描述：实现一个函数f，该函数接收n作为参数，并返回一个大小为n的列表，其中索引i处的元素值是i的阶乘（如果i是偶数）或者是从1到i的数字之和（如果i是奇数）。\ni从1开始。i的阶乘是从1到i的数字的乘积（1 * 2 * ... * i）。\n示例：\nf(5) == [1, 2, 6, 24, 15]\n代码如下：\n```python\ndef f(n):\n"}
{"task_id": "HumanEval/107", "prompt": "问题描述：给定一个正整数n，返回一个元组，该元组包含在范围(1, n)内（包括n）的偶数和奇数整数回文数的数量。\n示例 1：\n输入：3\n输出：(1, 2)\n解释：\n整数回文数有1，2，3。其中一个是偶数，两个是奇数。\n示例 2：\n输入：12\n输出：(4, 6)\n解释：\n整数回文数有1，2，3，4，5，6，7，8，9，11。其中四个是偶数，六个是奇数。\n注意：\n1. 1 <= n <= 10^3\n2. 返回的元组分别表示偶数和奇数整数回文数的数量。\n代码如下：\n```python\ndef even_odd_palindrome(n):\n"}
{"task_id": "HumanEval/108", "prompt": "问题描述：编写一个名为count_nums的函数，该函数接收一个整数数组，并返回其数字之和大于0的元素数量。如果一个数字是负数，那么它的第一个符号位将是负的：例如，-123的符号位是-1，2和3。\n示例：\n>>> count_nums([]) == 0\n>>> count_nums([-1, 11, -11]) == 1\n>>> count_nums([1, 1, 2]) == 3\n代码如下：\n```python\ndef count_nums(arr):\n"}
{"task_id": "HumanEval/109", "prompt": "问题描述：我们有一个由N个整数arr[1]，arr[2]，...，arr[N]组成的数组'arr'。数组中的数字将被随机排序。你的任务是确定是否可以通过在给定数组上执行以下操作来得到一个按非递减顺序排序的数组：你可以执行任意次数的右移操作。一次右移操作意味着将数组的所有元素向右方向移动一位。数组的最后一个元素将被移动到数组的起始位置，即0号索引。如果能够通过执行上述操作获得排序数组，则返回True，否则返回False。如果给定的数组为空，则返回True。注意：给定列表的元素保证是唯一的。\n例如：\nmove_one_ball([3, 4, 5, 1, 2])==>True\n解释：通过执行2次右移操作，可以实现给定数组的非递减顺序。\nmove_one_ball([3, 5, 4, 1, 2])==>False\n解释：对于给定的数组，无法通过执行任何数量的右移操作来获得非递减顺序。\n代码如下：\n```python\ndef move_one_ball(arr):\n"}
{"task_id": "HumanEval/110", "prompt": "问题描述：在这个问题中，你需要实现一个函数，该函数接收两个数字列表，并确定是否可以通过它们之间的元素交换使lst1成为一个只包含偶数的列表。在lst1和lst2之间交换元素的数量没有限制。如果可以通过交换lst1和lst2的元素使得lst1的所有元素都变为偶数，则返回\"YES\"。否则，返回\"NO\"。\n例如：\nexchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\nexchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n假设输入的列表都不会为空。\n代码如下：\n```python\ndef exchange(lst1, lst2):\n"}
{"task_id": "HumanEval/111", "prompt": "问题描述：给定一个表示空格分隔的小写字母的字符串，返回一个字典，该字典包含重复次数最多的字母和相应的计数。如果有多个字母出现次数相同，则返回它们全部。\n示例：\nhistogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\nhistogram('a b b a') == {'a': 2, 'b': 2}\nhistogram('a b c a b') == {'a': 2, 'b': 2}\nhistogram('b b b b a') == {'b': 4}\nhistogram('') == {}\n代码如下：\n```python\ndef histogram(test):\n"}
{"task_id": "HumanEval/112", "prompt": "问题描述：我们有两个字符串s和c，你需要删除s中所有与c中任何字符相同的字符，然后检查结果字符串是否为回文。如果一个字符串正读和反读都一样，那么这个字符串就被称为回文。你应该返回一个元组，包含结果字符串和对检查的True/False。\n示例：\n对于 s = \"abcde\", c = \"ae\", 结果应为 ('bcd',False)\n对于 s = \"abcdef\", c = \"b\"，结果应为 ('acdef',False)\n对于 s = \"abcdedcba\", c = \"ab\", 结果应为 ('cdedc',True)\n代码如下：\n```python\ndef reverse_delete(s,c):\n"}
{"task_id": "HumanEval/113", "prompt": "问题描述：给定一个由字符串组成的列表，其中每个字符串只包含数字，返回一个列表。输出中的每个元素应该是’the number of odd elements in the string i of the input.’，句子中所有的i都应该被替换为对应的输入字符串中奇数数字的数量。\n示例：\n>>> odd_count(['1234567'])\n[\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n示例：\n>>> odd_count(['3',\"11111111\"])\n[\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n代码如下：\n```python\ndef odd_count(lst):\n"}
{"task_id": "HumanEval/114", "prompt": "问题描述：给定一个整数数组 nums，找出任意非空子数组的最小和。\n示例：\nminSubArraySum([2, 3, 4, 1, 2, 4]) == 1\nminSubArraySum([-1, -2, -3]) == -6\n代码如下：\n```python\ndef minSubArraySum(nums):\n"}
{"task_id": "HumanEval/115", "prompt": "问题描述：给定一个矩形的水井网格。每一行代表一个井，每一行中的1代表一单位的水。每个井都有一个对应的桶，可以用来从井中抽取水，而且所有的桶容量都相同。你的任务是使用这些桶来排空井中的水。输出你需要降低桶的次数。\n示例:\n>>> grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]，bucket_capacity : 1\n6\n>>> grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]，bucket_capacity : 2\n5\n>>> grid : [[0,0,0], [0,0,0]]，bucket_capacity : 5\n0\n约束:\n    * 所有的井的长度是相同的。\n    * 1 <= grid.length <= 10^2\n    * 1 <= grid[:,1].length <= 10^2\n    * grid[i][j] -> 0 | 1\n    * 1 <= capacity <= 10\n代码如下：\n```python\ndef max_fill(grid, capacity):\n    import math\n"}
{"task_id": "HumanEval/116", "prompt": "问题描述：在这个Kata中，你需要根据二进制表示中的1的数量对一个非负整数数组进行升序排序。如果1的数量相同，那么就根据十进制值进行排序。\n它应该像这样实现：\n示例：\n>>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n>>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n>>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n代码如下：\n```python\ndef sort_array(arr):\n"}
{"task_id": "HumanEval/117", "prompt": "问题描述：给定一个字符串s和一个自然数n，你的任务是实现一个函数，返回字符串s中所有恰好包含n个辅音字母的单词的列表，这些单词应按照它们在字符串s中出现的顺序排列。如果字符串s为空，则函数应返回一个空列表。注意：你可以假设输入字符串只包含字母和空格。\n示例：\nselect_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\nselect_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\nselect_words(\"simple white space\", 2) ==> []\nselect_words(\"Hello world\", 4) ==> [\"world\"]\nselect_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n代码如下：\n```python\ndef select_words(s, n):\n"}
{"task_id": "HumanEval/118", "prompt": "问题描述：你会得到一个单词。你的任务是从右侧开始，找到位于两个辅音之间的，最靠近右侧的元音（区分大小写）。词首和词尾的元音不计算在内。如果你没有找到符合上述条件的任何元音，请返回空字符串。你可以假设给定的字符串只包含英文字母。\n示例：\nget_closest_vowel(\"yogurt\") ==> \"u\"\nget_closest_vowel(\"FULL\") ==> \"U\"\nget_closest_vowel(\"quick\") ==> \"\"\nget_closest_vowel(\"ab\") ==> \"\"\n代码如下：\n```python\ndef get_closest_vowel(word):\n"}
{"task_id": "HumanEval/119", "prompt": "问题描述：你将得到一个包含两个字符串的列表，这两个字符串仅由开括号 '(' 或闭括号 ')' 组成。你的任务是检查是否有可能以某种顺序连接这两个字符串，使得结果字符串是好的。只有当字符串 S 中的所有括号都平衡时，才认为它是好的。例如：字符串 '(())()' 是好的，而字符串 '())' 则不是。如果有办法生成一个好的字符串，则返回 'Yes'，否则返回 'No'。\n示例：\nmatch_parens(['()(', ')']) == 'Yes'\nmatch_parens([')', ')']) == 'No'\n代码如下：\n```python\ndef match_parens(lst):\n"}
{"task_id": "HumanEval/120", "prompt": "问题描述：给定一个整数数组 arr 和一个正整数 k，返回一个长度为 k 的排序列表，其中包含 arr 中最大的 k 个数字。\n示例 1：\n输入：arr = [-3, -4, 5], k = 3\n输出：[-4, -3, 5]\n示例 2：\n输入：arr = [4, -4, 4], k = 2\n输出：[4, 4]\n示例 3：\n输入：arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n输出：[2]\n注意：\n1. 数组的长度将在 [1, 1000] 的范围内。\n2. 数组中的元素将在 [-1000, 1000] 的范围内。\n3. 0 <= k <= len(arr)\n代码如下：\n```python\ndef maximum(arr, k):\n"}
{"task_id": "HumanEval/121", "prompt": "问题描述：给定一个非空的整数列表，返回所有在偶数位置的奇数元素之和。\n示例：\nsolution([5, 8, 7, 1]) ==> 12\nsolution([3, 3, 3, 3, 3]) ==> 9\nsolution([30, 13, 24, 321]) ==>0\n代码如下：\n```python\ndef solution(lst):\n"}
{"task_id": "HumanEval/122", "prompt": "问题描述：给定一个非空整数数组arr和一个整数k，返回arr的前k个元素中最多有两位数的元素之和。\n示例：\n输入：arr = [111,21,3,4000,5,6,7,8,9], k = 4\n输出：24 # 21 + 3 的和\n约束条件：\n1. 1 <= len(arr) <= 100\n2. 1 <= k <= len(arr)\n代码如下：\n```python\ndef add_elements(arr, k):\n"}
{"task_id": "HumanEval/123", "prompt": "问题描述：给定一个正整数n，返回一个排序列表，该列表包含了Collatz序列中的奇数。Collatz猜想是数学中的一个猜想，涉及到如下定义的序列：从任何一个正整数n开始。然后每个项都是根据前一个项得出的：如果前一个项是偶数，那么下一个项就是前一个项的一半。如果前一个项是奇数，那么下一个项就是前一个项的3倍加一。这个猜想是无论n的值是多少，这个序列最终总会达到1。\n注意：\n    1. Collatz(1) 是 [1]。\n    2. 返回的列表按照递增顺序排序。\n例如：\nget_odd_collatz(5) 返回 [1, 5] # 5的Collatz序列是 [5, 16, 8, 4, 2, 1]，所以奇数只有1和5。\n代码如下：\n```python\ndef get_odd_collatz(n):\n"}
{"task_id": "HumanEval/124", "prompt": "问题描述：你需要编写一个函数来验证给定的日期字符串，如果日期有效则返回True，否则返回False。日期是否有效取决于以下所有规则：\n1. 日期字符串不能为空。\n2. 对于月份为1,3,5,7,8,10,12的情况，天数不能少于1或超过31天。对于月份为4,6,9,11的情况，天数不能少于1或超过30天。对于2月，天数不能少于1或超过29天。\n3. 月份不能少于1或超过12。\n4. 日期应采用以下格式：mm-dd-yyyy\n例如：\nvalid_date('03-11-2000') => True\nvalid_date('15-01-2012') => False\nvalid_date('04-0-2040') => False\nvalid_date('06-04-2020') => True\nvalid_date('06/04/2020') => False\n代码如下：\n```python\ndef valid_date(date):\n"}
{"task_id": "HumanEval/125", "prompt": "问题描述：给定一个字符串，如果字符串中存在空格，就根据空格将其分割为单词列表。如果没有空格，但有逗号','，则根据逗号进行分割。如果既没有空格也没有逗号，那么你应该返回字母表中顺序为奇数的小写字母的数量，其中ord('a') = 0, ord('b') = 1, ... ord('z') = 25。\n示例：\nsplit_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\nsplit_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\nsplit_words(\"abcdef\") == 3\n代码如下：\n```python\ndef split_words(txt):\n"}
{"task_id": "HumanEval/126", "prompt": "问题描述：给定一个数字列表，返回它们是否按升序排序。如果列表中有超过1个重复的相同数字，则返回False。假设没有负数，只有整数。\n示例：\nis_sorted([5]) ➞ True\nis_sorted([1, 2, 3, 4, 5]) ➞ True\nis_sorted([1, 3, 2, 4, 5]) ➞ False\nis_sorted([1, 2, 3, 4, 5, 6]) ➞ True\nis_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ True\nis_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ False\nis_sorted([1, 2, 2, 3, 3, 4]) ➞ True\nis_sorted([1, 2, 2, 2, 3, 4]) ➞ False\n代码如下：\n```python\ndef is_sorted(lst):\n"}
{"task_id": "HumanEval/127", "prompt": "问题描述：给定两个区间，每个区间都是一对整数。\n例如，区间 = (start, end) = (1, 2)。给定的区间是闭区间，意味着区间(start, end)包括开始值和结束值。对于每一个给定的区间，我们假设其开始值小于或等于其结束值。你的任务是确定这两个区间的交集长度是否为质数。例如，区间 (1, 3)，(2, 4) 的交集是 (2, 3)，其长度是1，不是质数。如果交集的长度是质数，返回 \"YES\"，否则，返回 \"NO\"。如果两个区间没有交集，也返回 \"NO\"。\n[输入/输出] 示例：\nintersection((1, 2), (2, 3)) ==> \"NO\"\nintersection((-1, 1), (0, 4)) ==> \"NO\"\nintersection((-3, -1), (-5, 5)) ==> \"YES\"\n代码如下：\n```python\ndef intersection(interval1, interval2):\n"}
{"task_id": "HumanEval/128", "prompt": "问题描述：你需要处理一个整数数组arr，返回这些整数的绝对值之和乘以数组中每个数字的符号的乘积，符号由1，-1或0表示。注意：如果arr为空，则返回None。\n示例：\n>>> prod_signs([1, 2, 2, -4]) == -9\n>>> prod_signs([0, 1]) == 0\n>>> prod_signs([]) == None\n代码如下：\n```python\ndef prod_signs(arr):\n"}
{"task_id": "HumanEval/129", "prompt": "问题描述：给定一个N行N列的网格（N >= 2）和一个正整数k，网格的每个单元格都包含一个值。在[1，N * N]的范围内的每个整数在网格的单元格上都只出现一次。你需要在网格中找到长度为k的最小路径。你可以从任何单元格开始，每一步都可以移动到任何相邻单元格，也就是说，你可以去与当前单元格共享边的单元格。请注意，长度为k的路径意味着访问恰好k个单元格（不必是不同的单元格）。你不能走出网格。如果路径A（长度为k）被认为小于路径B（长度为k），那么在制作路径A和B经过的单元格的值的有序列表（我们称之为lst_A和lst_B）后，如果lst_A在字典顺序上小于lst_B，也就是说，存在一个整数索引i（1 <= i <= k）使得lst_A[i] < lst_B[i]，并且对于任何j（1 <= j < i），我们有lst_A[j] = lst_B[j]。保证答案是唯一的。返回最小路径经过的单元格的值的有序列表。\n示例：\n输入：grid = [[1,2,3], [4,5,6], [7,8,9]], k = 3\n输出：[1, 2, 1]\n输入：grid = [[5,9,3], [4,1,6], [7,8,2]], k = 1\n输出：[1]\n代码如下：\n```python\ndef minPath(grid, k):\n"}
{"task_id": "HumanEval/130", "prompt": "问题描述：每个人都知道斐波那契数列，这是过去几个世纪以来数学家们深入研究的主题。然而，人们可能不了解的是Tribonacci数列。\nTribonacci数列由以下递归定义：\ntri(1) = 3\n如果n为偶数，tri(n) = 1 + n / 2。\n如果n为奇数，tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)。\n例如：\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n    = 2 + 3 + 3 = 8 \n给定一个非负整数n，你需要返回Tribonacci数列的前n + 1个数字的列表。\n示例：\ntri(3) = [1, 3, 2, 8]\n代码如下：\n```python\ndef tri(n):\n"}
{"task_id": "HumanEval/131", "prompt": "问题描述：给定一个正整数n，返回其所有奇数位的乘积。如果所有数字都是偶数，则返回0。\n例如：\ndigits(1)  == 1\ndigits(4)  == 0\ndigits(235) == 15\n代码如下：\n```python\ndef digits(n):\n"}
{"task_id": "HumanEval/132", "prompt": "问题描述：创建一个函数，该函数接收一个只包含方括号的字符串作为输入。当且仅当存在一个有效的方括号子序列，并且子序列中至少有一个括号是嵌套的，函数应返回True。\n示例：\nis_nested('[[]]') ➞ True\nis_nested('[]]]]]]][[[[[]') ➞ False\nis_nested('[][]') ➞ False\nis_nested('[]') ➞ False\nis_nested('[[][]]') ➞ True\nis_nested('[[]][[') ➞ True\n代码如下：\n```python\ndef is_nested(string):\n"}
{"task_id": "HumanEval/133", "prompt": "问题描述：你需要处理一个数字列表。你需要返回列表中每个数值平方后的总和，但在这之前，你首先需要将列表中的每个元素向上取整（向上取最接近的整数）。\n示例：\n对于列表 lst = [1,2,3]，输出应为 14\n对于列表 lst = [1,4,9]，输出应为 98\n对于列表 lst = [1,3,5,7]，输出应为 84\n对于列表 lst = [1.4,4.2,0]，输出应为 29\n对于列表 lst = [-2.4,1,1]，输出应为 6\n代码如下：\n```python\ndef sum_squares(lst):\n"}
{"task_id": "HumanEval/134", "prompt": "问题描述：创建一个函数，如果给定字符串的最后一个字符是字母并且不是单词的一部分，则返回True，否则返回False。注意：\"单词\"是由空格分隔的一组字符。\n示例：\ncheck_if_last_char_is_a_letter(\"apple pie\") ➞ False\ncheck_if_last_char_is_a_letter(\"apple pi e\") ➞ True\ncheck_if_last_char_is_a_letter(\"apple pi e \") ➞ False\ncheck_if_last_char_is_a_letter(\"\") ➞ False\n代码如下：\n```python\ndef check_if_last_char_is_a_letter(txt):\n"}
{"task_id": "HumanEval/135", "prompt": "问题描述：创建一个函数，该函数返回元素的最大索引，该元素不大于或等于其之前最相邻的元素。如果不存在这样的元素，则返回-1。给定的数组将不包含重复的值。\n示例：\ncan_arrange([1,2,4,3,5]) = 3\ncan_arrange([1,2,3]) = -1\n代码如下：\n```python\ndef can_arrange(arr):\n"}
{"task_id": "HumanEval/136", "prompt": "问题描述：创建一个函数，该函数返回一个元组(a, b)，其中 'a' 是列表中的最大负整数，'b' 是最小的正整数。如果列表中没有负整数或正整数，则返回 None。\n示例：\nlargest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\nlargest_smallest_integers([]) == (None, None)\nlargest_smallest_integers([0]) == (None, None)\n代码如下：\n```python\ndef largest_smallest_integers(lst):\n"}
{"task_id": "HumanEval/137", "prompt": "问题描述：创建一个函数，该函数接收整数、浮点数或表示实数的字符串，并以其给定的变量类型返回较大的变量。如果值相等，则返回None。注意：如果实数被表示为字符串，那么浮点可能是'.'或','。\n示例：\ncompare_one(1, 2.5) ➞ 2.5\ncompare_one(1, \"2,3\") ➞ \"2,3\"\ncompare_one(\"5,1\", \"6\") ➞ \"6\"\ncompare_one(\"1\", 1) ➞ None\n代码如下：\n```python\ndef compare_one(a, b):\n"}
{"task_id": "HumanEval/138", "prompt": "问题描述：判断给定的数字n是否可以表示为正好4个正偶数的和。\n示例：\nis_equal_to_sum_even(4) == False\nis_equal_to_sum_even(6) == False\nis_equal_to_sum_even(8) == True\n代码如下：\n```python\ndef is_equal_to_sum_even(n):\n"}
{"task_id": "HumanEval/139", "prompt": "问题描述：巴西阶乘定义如下：\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n其中 n > 0\n例如：\n>>> special_factorial(4)\n288\n这个函数会接收一个整数作为输入，然后返回这个整数的特殊阶乘。\n代码如下：\n```python\ndef special_factorial(n):\n"}
{"task_id": "HumanEval/140", "prompt": "问题描述：给定一个字符串文本，将其中的所有空格替换为下划线，如果一个字符串有超过2个连续的空格，那么将所有连续的空格替换为'-'。\n示例：\nfix_spaces(\"Example\") == \"Example\"\nfix_spaces(\"Example 1\") == \"Example_1\"\nfix_spaces(\" Example 2\") == \"_Example_2\"\nfix_spaces(\" Example   3\") == \"_Example-3\"\n代码如下：\n```python\ndef fix_spaces(text):\n"}
{"task_id": "HumanEval/141", "prompt": "问题描述：创建一个函数，该函数接收表示文件名的字符串，如果文件名有效，返回'Yes'，否则返回'No'。\n文件名被认为是有效的当且仅当满足以下所有条件：\n- 文件名中不应超过三个数字('0'-'9')。\n- 文件名中只包含一个点'.'。\n- 点前的子字符串不应为空，并且以拉丁字母表的一个字母开头('a'-'z' 和 'A'-'Z')。\n- 点后的子字符串应该是以下之一：['txt', 'exe', 'dll']\n示例：\nfile_name_check(\"example.txt\") # => 'Yes'\nfile_name_check(\"1example.dll\") # => 'No' (名称应以拉丁字母开头)\n代码如下：\n```python\ndef file_name_check(file_name):\n"}
{"task_id": "HumanEval/142", "prompt": "问题描述：这个函数将接收一个整数列表。对于列表中的所有条目，如果其索引是3的倍数，则该函数应将整数条目平方；如果其索引是4的倍数且不是3的倍数，则该函数应将整数条目立方。对于索引既非3的倍数也非4的倍数的条目，该函数不会改变它们。然后，函数应返回所有条目的总和。\n示例：\n对于 lst = [1,2,3]，输出应为 6\n对于 lst = []，输出应为 0\n对于 lst = [-1,-5,2,-1,-5]，输出应为 -126\n代码如下：\n```python\ndef sum_squares(lst):\n"}
{"task_id": "HumanEval/143", "prompt": "问题描述：你将得到一个代表句子的字符串，这个句子包含一些由空格分隔的单词，你需要返回一个新的字符串，其中包含原始句子中长度为质数的单词，新字符串中的单词顺序应与原始句子相同。\n示例 1：\n输入：sentence = \"This is a test\"\n输出：\"is\"\n示例 2：\n输入：sentence = \"lets go for swimming\"\n输出：\"go for\"\n约束条件：\n* 1 <= len(sentence) <= 100\n* 句子只包含字母\n代码如下：\n```python\ndef words_in_sentence(sentence):\n"}
{"task_id": "HumanEval/144", "prompt": "问题描述：你的任务是实现一个函数，用于简化表达式 x * n。如果 x * n 的结果为整数，则函数返回True，否则返回False。其中，x 和 n 都是分数的字符串表示形式，格式为 <分子>/<分母>，分子和分母都是正整数。你可以假设 x 和 n 都是有效的分数，并且分母不为零。\n例如：\nsimplify(\"1/5\", \"5/1\") = True\nsimplify(\"1/6\", \"2/1\") = False\nsimplify(\"7/10\", \"10/2\") = False\n代码如下：\n```python\ndef simplify(x, n):\n"}
{"task_id": "HumanEval/145", "prompt": "问题描述：编写一个函数，该函数根据给定整数列表中每个数字的各位数之和进行升序排序。注意：如果有多个项的各位数之和相同，则根据它们在原始列表中的索引进行排序。\n例如：\n>>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n>>> order_by_points([]) == []\n代码如下：\n```python\ndef order_by_points(nums):\n"}
{"task_id": "HumanEval/146", "prompt": "问题描述：编写一个函数，该函数接收一个数字数组作为输入，并返回数组中大于10且数字的首尾位都是奇数（1、3、5、7、9）的元素数量。\n例如：\nspecialFilter([15, -73, 14, -15]) => 1 \nspecialFilter([33, -2, -3, 45, 21, 109]) => 2\n代码如下：\n```python\ndef specialFilter(nums):\n"}
{"task_id": "HumanEval/147", "prompt": "问题描述：你得到了一个正整数n。你需要创建一个长度为n的整数数组a。对于每个i (1 ≤ i ≤ n)，数组a的值a[i] = i * i - i + 1。返回数组a中满足i < j < k，且a[i] + a[j] + a[k]是3的倍数的三元组(a[i], a[j], a[k])的数量。\n示例：\n    输入：n = 5\n    输出：1\n    解释：\n    a = [1, 3, 7, 13, 21]\n    唯一有效的三元组是(1, 7, 13)。\n代码如下：\n```python\ndef get_max_triples(n):\n"}
{"task_id": "HumanEval/148", "prompt": "问题描述：这是一个关于我们太阳系的八大行星的问题：离太阳最近的是Mercury，然后是Venus，Earth，Mars，Jupiter，Saturn，Uranus，和Neptune。编写一个函数，该函数接受两个行星名称作为字符串planet1和planet2。 函数应返回一个包含所有位于planet1和planet2轨道之间的行星的元组，按照靠近太阳的顺序排序。 如果planet1或planet2不是正确的行星名称，函数应返回一个空元组。 \n示例：\nbf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\nbf(\"Earth\", \"Mercury\") ==> (\"Venus\")\nbf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n代码如下：\n```python\ndef bf(planet1, planet2):\n"}
{"task_id": "HumanEval/149", "prompt": "问题描述：编写一个函数，该函数接受一个字符串列表作为参数，删除其中长度为奇数的字符串，并以排序的方式返回结果列表，这个列表总是由字符串组成，而不是数字数组，并且可能包含重复项。列表应按每个单词的长度升序排列，并且应按此规则返回排序的列表。如果两个单词长度相同，按字母顺序排序列表。函数应返回一个按排序顺序的字符串列表。你可以假设所有单词的长度都是相同的。\n例如：\nassert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\nassert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n代码如下：\n```python\ndef sorted_list_sum(lst):\n"}
{"task_id": "HumanEval/150", "prompt": "问题描述：一个简单的程序，如果n是一个质数，那么它应该返回x的值，否则应该返回y的值。\n示例：\n对于 x_or_y(7, 34, 12)，结果应为 34\n对于 x_or_y(15, 8, 5)，结果应为 5\n代码如下：\n```python\ndef x_or_y(n, x, y):\n"}
{"task_id": "HumanEval/151", "prompt": "问题描述：给定一个数字列表，返回列表中奇数的平方和。忽略负数或非整数。\n示例：\ndouble_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\ndouble_the_difference([-1, -2, 0]) == 0\ndouble_the_difference([9, -2]) == 81\ndouble_the_difference([0]) == 0  \n如果输入列表为空，返回0。\n代码如下：\n```python\ndef double_the_difference(lst):\n"}
{"task_id": "HumanEval/152", "prompt": "问题描述：我想我们都记得那种当某个期待已久的事件的结果最终揭晓时的感觉。那一刻你的感受和想法绝对值得记录下来并进行比较。你的任务是确定一个人是否正确地猜测了一系列比赛的结果。你将得到两个长度相等的比分和猜测数组，其中每个索引表示一场比赛。返回一个长度相同的数组，表示每次猜测的偏差程度。如果他们猜对了，值就是0，如果没有，值就是猜测和比分之间的绝对差值。\n示例：\ncompare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\ncompare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n代码如下：\n```python\ndef compare(game,guess):\n"}
{"task_id": "HumanEval/153", "prompt": "问题描述：你将得到一个类的名称（一个字符串）和一组扩展名。这些扩展名是用于加载到类中的额外类。扩展的强度以如下方式确定：设CAP为扩展名中大写字母的数量，SM为扩展名中小写字母的数量，那么强度就由算式CAP-SM给出。你应该找到最强的扩展，并以这种格式返回一个字符串：ClassName.StrongestExtensionName。如果有两个或更多的扩展具有相同的强度，你应该选择列表中最早出现的那个。例如，如果你得到\"Slices\"作为类，以及一组扩展：['SErviNGSliCes', 'Cheese', 'StuFfed']，那么你应该返回'Slices.SErviNGSliCes'，因为'SErviNGSliCes'是最强的扩展（其强度为-1）。例如：对于Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'。\n代码如下：\n```python\ndef Strongest_Extension(class_name, extensions):\n"}
{"task_id": "HumanEval/154", "prompt": "问题描述：你被给予两个单词。如果第二个单词或其任何旋转版本是第一个单词的子字符串，你需要返回True。\n示例：\ncycpattern_check(\"abcd\",\"abd\") => False\ncycpattern_check(\"hello\",\"ell\") => True\ncycpattern_check(\"whassup\",\"psus\") => False\ncycpattern_check(\"abab\",\"baa\") => True\ncycpattern_check(\"efef\",\"eeff\") => False\ncycpattern_check(\"himenss\",\"simen\") => True\n代码如下：\n```python\ndef cycpattern_check(a , b):\n"}
{"task_id": "HumanEval/155", "prompt": "问题描述：给定一个整数。返回一个元组，其中包含该整数中偶数和奇数数字的数量。\n示例：\n    even_odd_count(-12) ==> (1, 1)\n    even_odd_count(123) ==> (1, 2)\n代码如下：\n```python\ndef even_odd_count(num):\n"}
{"task_id": "HumanEval/156", "prompt": "问题描述：给定一个正整数，获取其对应的罗马数字字符串，并以小写形式返回。\n限制条件：1 <= 数字 <= 1000\n示例：\n>>> int_to_mini_roman(19) == 'xix'\n>>> int_to_mini_roman(152) == 'clii'\n>>> int_to_mini_roman(426) == 'cdxxvi'\n代码如下：\n```python\ndef int_to_mini_roman(number):\n"}
{"task_id": "HumanEval/157", "prompt": "问题描述：给定一个三角形的三条边的长度。如果这三条边构成一个直角三角形，返回True，否则返回False。直角三角形是一种有一个角为直角或90度的三角形。\n示例：\nright_angle_triangle(3, 4, 5) == True\nright_angle_triangle(1, 2, 3) == False\n代码如下：\n```python\ndef right_angle_triangle(a, b, c):\n"}
{"task_id": "HumanEval/158", "prompt": "问题描述：编写一个接受字符串列表的函数。列表包含不同的单词。返回具有最多唯一字符的单词。如果有多个字符串具有最大数量的唯一字符，按字典顺序返回第一个。\n示例：\nfind_max([\"name\", \"of\", \"string\"]) == \"string\"\nfind_max([\"name\", \"enam\", \"game\"]) == \"enam\"\nfind_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"aaaaaaa\"\n代码如下：\n```python\ndef find_max(words):\n"}
{"task_id": "HumanEval/159", "prompt": "问题描述：你是一只饥饿的兔子，你已经吃了一定数量的胡萝卜，但现在你需要吃更多的胡萝卜来完成一天的饭量。你应该返回一个数组，包括[吃完饭后吃掉的胡萝卜总数，吃完饭后剩下的胡萝卜数量]。如果剩下的胡萝卜不够，你会吃掉所有剩下的胡萝卜，但仍然会觉得饿。\n示例：\n* eat(5, 6, 10) -> [11, 4]\n* eat(4, 8, 9) -> [12, 1]\n* eat(1, 10, 10) -> [11, 0]\n* eat(2, 11, 5) -> [7, 0]\n变量：\n@number : 整数\n你已经吃掉的胡萝卜数量。\n@need : 整数\n你需要吃的胡萝卜数量。\n@remaining : 整数\n库存中剩余的胡萝卜数量\n约束：\n* 0 <= number <= 1000\n* 0 <= need <= 1000\n* 0 <= remaining <= 1000\n祝你玩得开心 :)\n代码如下：\n```python\ndef eat(number, need, remaining):\n"}
{"task_id": "HumanEval/160", "prompt": "问题描述：给定两个列表operator和operand。第一个列表包含基本的代数运算，第二个列表是一组整数。使用这两个给定的列表来构建代数表达式，并返回这个表达式的计算结果。\n基本的代数运算包括：\n加法 ( + ) \n减法 ( - ) \n乘法 ( * ) \n整除 ( // ) \n指数运算 ( ** ) \n示例：\noperator['+', '*', '-']\narray = [2, 3, 4, 5]\nresult = 2 + 3 * 4 - 5\n=> 结果 = 9\n注意：\n运算符列表的长度等于操作数列表的长度减一。\n操作数是非负整数的列表。\n运算符列表至少有一个运算符，操作数列表至少有两个操作数。\n代码如下：\n```python\ndef do_algebra(operator, operand):\n"}
{"task_id": "HumanEval/161", "prompt": "问题描述：给定一个字符串s。如果s[i]是一个字母，将其从小写转为大写，或者从大写转为小写，否则保持不变。如果字符串中不包含字母，则反转字符串。函数应返回结果字符串。\n示例：\nsolve(\"1234\") = \"4321\"\nsolve(\"ab\") = \"AB\"\nsolve(\"#a@C\") = \"#A@c\"\n代码如下：\n```python\ndef solve(s):\n"}
{"task_id": "HumanEval/162", "prompt": "问题描述：给定一个字符串'text'，返回其对应的md5 hash字符串。如果'text'是一个空字符串，则返回None。\n示例：\n>>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n代码如下：\n```python\ndef string_to_md5(text):\n"}
{"task_id": "HumanEval/163", "prompt": "问题描述：给定两个正整数a和b，返回a和b之间的偶数数字，按升序排列。\n例如：\ngenerate_integers(2, 8) => [2, 4, 6, 8]\ngenerate_integers(8, 2) => [2, 4, 6, 8]\ngenerate_integers(10, 14) => []\n代码如下：\n```python\ndef generate_integers(a, b):\n"}
